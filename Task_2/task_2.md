# 2. Контейнеризация и delivery (Docker Compose + CI)

## Контекст (что разворачиваем)

- Backend берётся из этой же репы: Flask API (MySQL + Redis), переменные окружения описаны в `backend/README.md`.
- Frontend берётся из этой же репы: статические файлы, обслуживаются Nginx; параметр `API_URL` подставляется через `envsubst`.

## Требования

### 1) Dockerfile’ы

#### Backend
- Перевести сборку backend в **multi-stage build** (builder + runtime).
- Runtime образ:
  - минимальный (slim), без лишних build-зависимостей;
  - процесс должен работать не от root (где это реалистично для стека);
  - `HEALTHCHECK` (например, проверка `GET /api/tasks` и кода ответа).

#### Frontend
- Реализовать **multi-stage build**:
  - build-stage: валидация (линтер) и/или сборка статических артефактов (если стэк позволяет); допустимо, что «build» — это хотя бы `npm ci` + `npm run lint`, если настоящей сборки нет.
  - runtime-stage: **Nginx**.

### 2) Nginx: reverse-proxy + SPA fallback + security headers

#### SPA fallback (History API)
Требование означает: если пользователь открывает URL вида `/tasks/123` напрямую, сервер должен вернуть **`index.html`**, чтобы роутинг продолжил работать на стороне SPA.

- В Nginx это обычно решается директивой вида `try_files $uri $uri/ /index.html;`.
- Важно: fallback **не должен ломать API** — пути `/api/*` должны проксироваться на backend без подмены на `index.html`.

Примечание: даже если текущий frontend по факту не использует History API роутинг, ожидается, что кандидат:
- корректно настроит fallback на уровне Nginx (как практика),
- и кратко опишет в README, как это работает и почему `/api/*` исключается.

#### Reverse proxy
- Поднять единый входной Nginx (или настроить Nginx фронта), чтобы:
  - `/` отдавал frontend;
  - `/api/` проксировал в backend.

#### Security headers (2–3 базовых)
Добавить минимум **2–3** заголовка (достаточно базовых значений):
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY` (или `SAMEORIGIN` — аргументировать выбор)
- `Referrer-Policy: no-referrer` (или другой осознанный вариант)

> Примечание: сложный/идеальный CSP не требуется, но можно добавить простой `Content-Security-Policy` если не ломает приложение.

### 3) Docker Compose: production-run

Собрать `docker-compose.yml`, который поднимает:
- `frontend` (Nginx runtime)
- `backend`
- `mysql`
- `redis`

Обязательные требования к Compose:
- **Networks**: отдельная сеть(и), чтобы сервисы общались по сервисным именам.
- **Healthchecks**:
  - MySQL: ожидание готовности.
  - Backend: HTTP health.
  - Frontend: опционально.
- **depends_on**: использовать осознанно (понимать, что это не «wait-for-ready»; готовность обеспечивать healthcheck’ами/скриптом ожидания).
- **Restart policy**: осознанные политики перезапуска.
- **Port exposure**: наружу публиковать только то, что нужно пользователю (обычно 80/443 на вход).

### 4) Переменные окружения: `.env.example` (обязательно)

Добавить `.env.example` в корень репозитория со **всеми** переменными, которые нужны для запуска через Compose.

Минимальный набор (можно расширять):
- `MYSQL_USER`, `MYSQL_PASSWORD`, `MYSQL_DB`
- хосты/порты сервисов, если нужны
- `FE_HOST` (для CORS на backend)
- `API_URL` (для frontend)

Требование: команда ревьюера должна уметь сделать `cp .env.example .env` и запустить.

### 5) Персистентность данных: Volumes (обязательно)

- Для БД: использовать **named volume** для `/var/lib/mysql`.
- Для Redis: 
  - если включена persistence, обеспечить volume для данных Redis;
  - если persistence выключена — Redis работает без volume (данные теряются при рестарте).

Важно: переключение persistence — это **не про backend**, а про конфигурацию Redis в Compose.

То есть не требуется, чтобы backend «поддерживал» включение/выключение persistence: backend просто использует Redis как сервис, а persistence управляется тем, как запущен Redis.

Ожидаемый формат решения (любой один вариант):
- либо два compose-профиля: `redis-ephemeral` и `redis-persistent`;
- либо два override-файла;
- либо два сервиса Redis (например `redis` и `redis_persist`) с профилями.

### 5.5) Инициализация/«миграции» БД (обязательно)

Даже если приложение создаёт таблицы через `db.create_all()`, нужно сделать запуск **детерминированным**:
- MySQL должен стартовать с созданной БД/пользователем.
- Backend не должен падать из-за того, что БД ещё не готова.

Пояснение: `db.create_all()` создаёт таблицы при старте приложения, но это не решает проблему «БД ещё не поднялась» и не фиксирует схему как артефакт доставки. Поэтому ожидается либо init-скрипт MySQL + ожидание готовности, либо полноценные миграции (опционально — если кандидат хочет показать уровень).

Ожидается одно из решений (выбрать и описать в README):
- **Init script** для MySQL (например, `docker-entrypoint-initdb.d`), плюс ожидание готовности перед стартом backend.
- Либо внедрить нормальные миграции (например, Alembic/Flask-Migrate) и добавить одноразовый шаг `migrate`/`upgrade` (как отдельный сервис или init job в Compose).

Критерий: после `docker compose up -d` приложение доступно, таблица `task` существует, CRUD работает.

### 6) Dev-режим (обязательно)

Добавить **отдельный compose-профиль** `dev` или отдельный файл `docker-compose.dev.yml`.

Что ожидается в `dev`:
- Backend:
  - bind-mount исходников;
  - режим авто-перезагрузки (Flask debug/reload), если это реально для текущего приложения.
- Frontend:
  - допустимо просто bind-mount статических файлов (Nginx будет отдавать актуальное содержимое).

Какие изменения в Compose ожидаются в `dev` (примерно, без жёсткой привязки к конкретной реализации):
- добавить bind-mount’ы (`./backend` внутрь контейнера backend, `./frontend` внутрь контейнера фронта),
- поменять команду/entrypoint backend на режим с auto-reload,
- (опционально) пробросить наружу порт backend для отладки,
- при этом базовые зависимости (MySQL/Redis) остаются как есть.

Что НЕ ожидается:
- полноценные «staging/prod» окружения, сложная матрица конфигов, Helm/K8s.

### 7) CI (обязательно)

Добавить минимальный pipeline (GitHub Actions или GitLab CI — на выбор):
- Линтеры:
  - backend: `flake8`, `isort`, `black` (как указано в `backend/README.md`).
  - frontend: `eslint` (как указано в `frontend/README.md`).
- Тесты:
  - backend: `pytest` (unit тесты, которые не требуют MySQL/Redis).
- Контейнеры:
  - сборка Docker образов.
  - базовый security scan образов (например, Trivy) — достаточно fail-on-high/critical.

## Результат выполнения

В репозитории должны появиться:
- `docker-compose.yml`
- `docker-compose.dev.yml` (или `profiles` внутри compose)
- `.env.example`
- Nginx конфиг(и) для proxy + SPA fallback + headers
- обновлённые Dockerfile’ы (multi-stage где требуется)
- CI конфигурация
- README (корневой или отдельный) с командами запуска для `prod` и `dev`

## Критерии оценки

- Воспроизводимость: запуск одной командой, понятный `.env.example`.
- Надёжность: сервисы корректно ждут зависимости, есть healthchecks.
- Безопасность: минимум 2–3 headers + базовое hardening образов.
- Dev UX: dev-режим реально помогает (bind mounts + reload).
- CI: линтеры/тесты/сборка/сканирование работают.
